"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkazamex_manage_app"] = self["webpackChunkazamex_manage_app"] || []).push([["node_modules_vueform_multiselect_dist_multiselect_mjs"],{

/***/ "./node_modules/@vueform/multiselect/dist/multiselect.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@vueform/multiselect/dist/multiselect.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ script; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n\n\nfunction isNullish(val) {\n  return [null, undefined].indexOf(val) !== -1;\n}\nfunction useData(props, context, dep) {\n  const {\n    object,\n    valueProp,\n    mode\n  } = (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRefs)(props);\n  const $this = (0,vue__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance)().proxy;\n\n  // ============ DEPENDENCIES ============\n\n  const iv = dep.iv;\n\n  // =============== METHODS ==============\n\n  const update = (val, triggerInput = true) => {\n    // Setting object(s) as internal value\n    iv.value = makeInternal(val);\n\n    // Setting object(s) or plain value as external \n    // value based on `option` setting\n    const externalVal = makeExternal(val);\n    context.emit('change', externalVal, $this);\n    if (triggerInput) {\n      context.emit('input', externalVal);\n      context.emit('update:modelValue', externalVal);\n    }\n  };\n\n  // no export\n  const makeExternal = val => {\n    // If external value should be object\n    // no transformation is required\n    if (object.value) {\n      return val;\n    }\n\n    // No need to transform if empty value\n    if (isNullish(val)) {\n      return val;\n    }\n\n    // If external should be plain transform\n    // value object to plain values\n    return !Array.isArray(val) ? val[valueProp.value] : val.map(v => v[valueProp.value]);\n  };\n\n  // no export\n  const makeInternal = val => {\n    if (isNullish(val)) {\n      return mode.value === 'single' ? {} : [];\n    }\n    return val;\n  };\n  return {\n    update\n  };\n}\nfunction useValue(props, context) {\n  const {\n    value,\n    modelValue,\n    mode,\n    valueProp\n  } = (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRefs)(props);\n\n  // ================ DATA ================\n\n  // internalValue\n  const iv = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(mode.value !== 'single' ? [] : {});\n\n  // ============== COMPUTED ==============\n\n  /* istanbul ignore next */\n  // externalValue\n  const ev = modelValue && modelValue.value !== undefined ? modelValue : value;\n  const plainValue = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return mode.value === 'single' ? iv.value[valueProp.value] : iv.value.map(v => v[valueProp.value]);\n  });\n  const textValue = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return mode.value !== 'single' ? iv.value.map(v => v[valueProp.value]).join(',') : iv.value[valueProp.value];\n  });\n  return {\n    iv,\n    internalValue: iv,\n    ev,\n    externalValue: ev,\n    textValue,\n    plainValue\n  };\n}\nfunction useSearch(props, context, dep) {\n  const {\n    regex\n  } = (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRefs)(props);\n  const $this = (0,vue__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance)().proxy;\n\n  // ============ DEPENDENCIES ============\n\n  const isOpen = dep.isOpen;\n  const open = dep.open;\n\n  // ================ DATA ================\n\n  const search = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const input = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n\n  // =============== METHODS ==============\n\n  const clearSearch = () => {\n    search.value = '';\n  };\n  const handleSearchInput = e => {\n    search.value = e.target.value;\n  };\n  const handleKeypress = e => {\n    if (regex && regex.value) {\n      let regexp = regex.value;\n      if (typeof regexp === 'string') {\n        regexp = new RegExp(regexp);\n      }\n      if (!e.key.match(regexp)) {\n        e.preventDefault();\n      }\n    }\n  };\n  const handlePaste = e => {\n    if (regex && regex.value) {\n      let clipboardData = e.clipboardData || /* istanbul ignore next */window.clipboardData;\n      let pastedData = clipboardData.getData('Text');\n      let regexp = regex.value;\n      if (typeof regexp === 'string') {\n        regexp = new RegExp(regexp);\n      }\n      if (!pastedData.split('').every(c => !!c.match(regexp))) {\n        e.preventDefault();\n      }\n    }\n    context.emit('paste', e, $this);\n  };\n\n  // ============== WATCHERS ==============\n\n  (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(search, val => {\n    if (!isOpen.value && val) {\n      open();\n    }\n    context.emit('search-change', val, $this);\n  });\n  return {\n    search,\n    input,\n    clearSearch,\n    handleSearchInput,\n    handleKeypress,\n    handlePaste\n  };\n}\nfunction usePointer$1(props, context, dep) {\n  const {\n    groupSelect,\n    mode,\n    groups,\n    disabledProp\n  } = (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRefs)(props);\n\n  // ================ DATA ================\n\n  const pointer = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n\n  // =============== METHODS ==============\n\n  const setPointer = option => {\n    if (option === undefined || option !== null && option[disabledProp.value]) {\n      return;\n    }\n    if (groups.value && option && option.group && (mode.value === 'single' || !groupSelect.value)) {\n      return;\n    }\n    pointer.value = option;\n  };\n  const clearPointer = () => {\n    setPointer(null);\n  };\n  return {\n    pointer,\n    setPointer,\n    clearPointer\n  };\n}\nfunction normalize(str, strict = true) {\n  return strict ? String(str).toLowerCase().trim() : String(str).toLowerCase().normalize('NFD').trim().replace(new RegExp(/æ/g), 'ae').replace(new RegExp(/œ/g), 'oe').replace(new RegExp(/ø/g), 'o').replace(/\\p{Diacritic}/gu, '');\n}\nfunction isObject(variable) {\n  return Object.prototype.toString.call(variable) === '[object Object]';\n}\nfunction arraysEqual(array1, array2) {\n  const array2Sorted = array2.slice().sort();\n  return array1.length === array2.length && array1.slice().sort().every(function (value, index) {\n    return value === array2Sorted[index];\n  });\n}\nfunction useOptions(props, context, dep) {\n  const {\n    options,\n    mode,\n    trackBy: trackBy_,\n    limit,\n    hideSelected,\n    createTag,\n    createOption: createOption_,\n    label,\n    appendNewTag,\n    appendNewOption: appendNewOption_,\n    multipleLabel,\n    object,\n    loading,\n    delay,\n    resolveOnLoad,\n    minChars,\n    filterResults,\n    clearOnSearch,\n    clearOnSelect,\n    valueProp,\n    allowAbsent,\n    groupLabel,\n    canDeselect,\n    max,\n    strict,\n    closeOnSelect,\n    closeOnDeselect,\n    groups: groupped,\n    reverse,\n    infinite,\n    groupOptions,\n    groupHideEmpty,\n    groupSelect,\n    onCreate,\n    disabledProp,\n    searchStart,\n    searchFilter\n  } = (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRefs)(props);\n  const $this = (0,vue__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance)().proxy;\n\n  // ============ DEPENDENCIES ============\n\n  const iv = dep.iv;\n  const ev = dep.ev;\n  const search = dep.search;\n  const clearSearch = dep.clearSearch;\n  const update = dep.update;\n  const pointer = dep.pointer;\n  const clearPointer = dep.clearPointer;\n  const focus = dep.focus;\n  const deactivate = dep.deactivate;\n  const close = dep.close;\n  const localize = dep.localize;\n\n  // ================ DATA ================\n\n  // no export\n  // appendedOptions\n  const ap = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)([]);\n\n  // no export\n  // resolvedOptions\n  const ro = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)([]);\n  const resolving = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n\n  // no export\n  const searchWatcher = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const offset = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(infinite.value && limit.value === -1 ? 10 : limit.value);\n\n  // ============== COMPUTED ==============\n\n  // no export\n  const createOption = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return createTag.value || createOption_.value || false;\n  });\n\n  // no export\n  const appendNewOption = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (appendNewTag.value !== undefined) {\n      return appendNewTag.value;\n    } else if (appendNewOption_.value !== undefined) {\n      return appendNewOption_.value;\n    }\n    return true;\n  });\n\n  // no export\n  // extendedOptions\n  const eo = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (groupped.value) {\n      let groups = eg.value || /* istanbul ignore next */[];\n      let eo = [];\n      groups.forEach(group => {\n        optionsToArray(group[groupOptions.value]).forEach(option => {\n          eo.push(Object.assign({}, option, group[disabledProp.value] ? {\n            [disabledProp.value]: true\n          } : {}));\n        });\n      });\n      return eo;\n    } else {\n      let eo = optionsToArray(ro.value || /* istanbul ignore next */[]);\n      if (ap.value.length) {\n        eo = eo.concat(ap.value);\n      }\n      return eo;\n    }\n  });\n\n  // preFilteredOptions\n  const pfo = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    let options = eo.value;\n    if (reverse.value) {\n      options = options.reverse();\n    }\n    if (createdOption.value.length) {\n      options = createdOption.value.concat(options);\n    }\n    return filterOptions(options);\n  });\n\n  // filteredOptions\n  const fo = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    let options = pfo.value;\n    if (offset.value > 0) {\n      options = options.slice(0, offset.value);\n    }\n    return options;\n  });\n\n  // no export\n  // extendedGroups\n  const eg = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (!groupped.value) {\n      return [];\n    }\n    let eg = [];\n    let groups = ro.value || /* istanbul ignore next */[];\n    if (ap.value.length) {\n      eg.push({\n        [groupLabel.value]: ' ',\n        [groupOptions.value]: [...ap.value],\n        __CREATE__: true\n      });\n    }\n    return eg.concat(groups);\n  });\n\n  // preFilteredGroups\n  const pfg = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    let groups = [...eg.value].map(g => ({\n      ...g\n    }));\n    if (createdOption.value.length) {\n      if (groups[0] && groups[0].__CREATE__) {\n        groups[0][groupOptions.value] = [...createdOption.value, ...groups[0][groupOptions.value]];\n      } else {\n        groups = [{\n          [groupLabel.value]: ' ',\n          [groupOptions.value]: [...createdOption.value],\n          __CREATE__: true\n        }].concat(groups);\n      }\n    }\n    return groups;\n  });\n\n  // filteredGroups\n  const fg = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (!groupped.value) {\n      return [];\n    }\n    let options = pfg.value;\n    return filterGroups((options || /* istanbul ignore next */[]).map((group, index) => {\n      const arrayOptions = optionsToArray(group[groupOptions.value]);\n      return {\n        ...group,\n        index,\n        group: true,\n        [groupOptions.value]: filterOptions(arrayOptions, false).map(o => Object.assign({}, o, group[disabledProp.value] ? {\n          [disabledProp.value]: true\n        } : {})),\n        __VISIBLE__: filterOptions(arrayOptions).map(o => Object.assign({}, o, group[disabledProp.value] ? {\n          [disabledProp.value]: true\n        } : {}))\n      };\n      // Difference between __VISIBLE__ and {groupOptions}: visible does not contain selected options when hideSelected=true\n    }));\n  });\n\n  const hasSelected = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    switch (mode.value) {\n      case 'single':\n        return !isNullish(iv.value[valueProp.value]);\n      case 'multiple':\n      case 'tags':\n        return !isNullish(iv.value) && iv.value.length > 0;\n    }\n  });\n  const multipleLabelText = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return multipleLabel !== undefined && multipleLabel.value !== undefined ? multipleLabel.value(iv.value, $this) : iv.value && iv.value.length > 1 ? `${iv.value.length} options selected` : `1 option selected`;\n  });\n  const noOptions = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return !eo.value.length && !resolving.value && !createdOption.value.length;\n  });\n  const noResults = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return eo.value.length > 0 && fo.value.length == 0 && (search.value && groupped.value || !groupped.value);\n  });\n\n  // no export\n  const createdOption = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (createOption.value === false || !search.value) {\n      return [];\n    }\n    if (getOptionByTrackBy(search.value) !== -1) {\n      return [];\n    }\n    return [{\n      [valueProp.value]: search.value,\n      [trackBy.value]: search.value,\n      [label.value]: search.value,\n      __CREATE__: true\n    }];\n  });\n  const trackBy = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return trackBy_.value || label.value;\n  });\n\n  // no export\n  const nullValue = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    switch (mode.value) {\n      case 'single':\n        return null;\n      case 'multiple':\n      case 'tags':\n        return [];\n    }\n  });\n  const busy = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return loading.value || resolving.value;\n  });\n\n  // =============== METHODS ==============\n\n  /**\n   * @param {array|object|string|number} option \n   */\n  const select = option => {\n    if (typeof option !== 'object') {\n      option = getOption(option);\n    }\n    switch (mode.value) {\n      case 'single':\n        update(option);\n        break;\n      case 'multiple':\n      case 'tags':\n        update(iv.value.concat(option));\n        break;\n    }\n    context.emit('select', finalValue(option), option, $this);\n  };\n  const deselect = option => {\n    if (typeof option !== 'object') {\n      option = getOption(option);\n    }\n    switch (mode.value) {\n      case 'single':\n        clear();\n        break;\n      case 'tags':\n      case 'multiple':\n        update(Array.isArray(option) ? iv.value.filter(v => option.map(o => o[valueProp.value]).indexOf(v[valueProp.value]) === -1) : iv.value.filter(v => v[valueProp.value] != option[valueProp.value]));\n        break;\n    }\n    context.emit('deselect', finalValue(option), option, $this);\n  };\n\n  // no export\n  const finalValue = option => {\n    return object.value ? option : option[valueProp.value];\n  };\n  const remove = option => {\n    deselect(option);\n  };\n  const handleTagRemove = (option, e) => {\n    if (e.button !== 0) {\n      e.preventDefault();\n      return;\n    }\n    remove(option);\n  };\n  const clear = () => {\n    context.emit('clear', $this);\n    update(nullValue.value);\n  };\n  const isSelected = option => {\n    if (option.group !== undefined) {\n      return mode.value === 'single' ? false : areAllSelected(option[groupOptions.value]) && option[groupOptions.value].length;\n    }\n    switch (mode.value) {\n      case 'single':\n        return !isNullish(iv.value) && iv.value[valueProp.value] == option[valueProp.value];\n      case 'tags':\n      case 'multiple':\n        return !isNullish(iv.value) && iv.value.map(o => o[valueProp.value]).indexOf(option[valueProp.value]) !== -1;\n    }\n  };\n  const isDisabled = option => {\n    return option[disabledProp.value] === true;\n  };\n  const isMax = () => {\n    if (max === undefined || max.value === -1 || !hasSelected.value && max.value > 0) {\n      return false;\n    }\n    return iv.value.length >= max.value;\n  };\n  const handleOptionClick = option => {\n    if (isDisabled(option)) {\n      return;\n    }\n    if (onCreate && onCreate.value && !isSelected(option) && option.__CREATE__) {\n      option = {\n        ...option\n      };\n      delete option.__CREATE__;\n      option = onCreate.value(option, $this);\n      if (option instanceof Promise) {\n        resolving.value = true;\n        option.then(result => {\n          resolving.value = false;\n          handleOptionSelect(result);\n        });\n        return;\n      }\n    }\n    handleOptionSelect(option);\n  };\n  const handleOptionSelect = option => {\n    if (option.__CREATE__) {\n      option = {\n        ...option\n      };\n      delete option.__CREATE__;\n    }\n    switch (mode.value) {\n      case 'single':\n        if (option && isSelected(option)) {\n          if (canDeselect.value) {\n            deselect(option);\n          }\n          if (closeOnDeselect.value) {\n            clearPointer();\n            close();\n          }\n          return;\n        }\n        if (option) {\n          handleOptionAppend(option);\n        }\n\n        /* istanbul ignore else */\n        if (clearOnSelect.value) {\n          clearSearch();\n        }\n        if (closeOnSelect.value) {\n          clearPointer();\n          close();\n        }\n        if (option) {\n          select(option);\n        }\n        break;\n      case 'multiple':\n        if (option && isSelected(option)) {\n          deselect(option);\n          if (closeOnDeselect.value) {\n            clearPointer();\n            close();\n          }\n          return;\n        }\n        if (isMax()) {\n          context.emit('max', $this);\n          return;\n        }\n        if (option) {\n          handleOptionAppend(option);\n          select(option);\n        }\n        if (clearOnSelect.value) {\n          clearSearch();\n        }\n        if (hideSelected.value) {\n          clearPointer();\n        }\n        if (closeOnSelect.value) {\n          close();\n        }\n        break;\n      case 'tags':\n        if (option && isSelected(option)) {\n          deselect(option);\n          if (closeOnDeselect.value) {\n            clearPointer();\n            close();\n          }\n          return;\n        }\n        if (isMax()) {\n          context.emit('max', $this);\n          return;\n        }\n        if (option) {\n          handleOptionAppend(option);\n        }\n        if (clearOnSelect.value) {\n          clearSearch();\n        }\n        if (option) {\n          select(option);\n        }\n        if (hideSelected.value) {\n          clearPointer();\n        }\n        if (closeOnSelect.value) {\n          close();\n        }\n        break;\n    }\n    if (!closeOnSelect.value) {\n      focus();\n    }\n  };\n  const handleGroupClick = group => {\n    if (isDisabled(group) || mode.value === 'single' || !groupSelect.value) {\n      return;\n    }\n    switch (mode.value) {\n      case 'multiple':\n      case 'tags':\n        if (areAllEnabledSelected(group[groupOptions.value])) {\n          deselect(group[groupOptions.value]);\n        } else {\n          select(group[groupOptions.value].filter(o => iv.value.map(v => v[valueProp.value]).indexOf(o[valueProp.value]) === -1).filter(o => !o[disabledProp.value]).filter((o, k) => iv.value.length + 1 + k <= max.value || max.value === -1));\n        }\n        break;\n    }\n    if (closeOnSelect.value) {\n      deactivate();\n    }\n  };\n  const handleOptionAppend = option => {\n    if (getOption(option[valueProp.value]) === undefined && createOption.value) {\n      context.emit('tag', option[valueProp.value], $this);\n      context.emit('option', option[valueProp.value], $this);\n      context.emit('create', option[valueProp.value], $this);\n      if (appendNewOption.value) {\n        appendOption(option);\n      }\n      clearSearch();\n    }\n  };\n  const selectAll = () => {\n    if (mode.value === 'single') {\n      return;\n    }\n    select(fo.value.filter(o => !o.disabled && !isSelected(o)));\n  };\n\n  // no export\n  const areAllEnabledSelected = options => {\n    return options.find(o => !isSelected(o) && !o[disabledProp.value]) === undefined;\n  };\n\n  // no export\n  const areAllSelected = options => {\n    return options.find(o => !isSelected(o)) === undefined;\n  };\n  const getOption = val => {\n    return eo.value[eo.value.map(o => String(o[valueProp.value])).indexOf(String(val))];\n  };\n\n  // no export\n  const getOptionByTrackBy = (val, norm = true) => {\n    return eo.value.map(o => parseInt(o[trackBy.value]) == o[trackBy.value] ? parseInt(o[trackBy.value]) : o[trackBy.value]).indexOf(parseInt(val) == val ? parseInt(val) : val);\n  };\n\n  // no export\n  const shouldHideOption = option => {\n    return ['tags', 'multiple'].indexOf(mode.value) !== -1 && hideSelected.value && isSelected(option);\n  };\n\n  // no export\n  const appendOption = option => {\n    ap.value.push(option);\n  };\n\n  // no export\n  const filterGroups = groups => {\n    // If the search has value we need to filter among \n    // the ones that are visible to the user to avoid\n    // displaying groups which technically have options\n    // based on search but that option is already selected.\n    return groupHideEmpty.value ? groups.filter(g => search.value ? g.__VISIBLE__.length : g[groupOptions.value].length) : groups.filter(g => search.value ? g.__VISIBLE__.length : true);\n  };\n\n  // no export\n  const filterOptions = (options, excludeHideSelected = true) => {\n    let fo = options;\n    if (search.value && filterResults.value) {\n      let filter = searchFilter.value;\n      if (!filter) {\n        filter = (option, $this) => {\n          let target = normalize(localize(option[trackBy.value]), strict.value);\n          return searchStart.value ? target.startsWith(normalize(search.value, strict.value)) : target.indexOf(normalize(search.value, strict.value)) !== -1;\n        };\n      }\n      fo = fo.filter(filter);\n    }\n    if (hideSelected.value && excludeHideSelected) {\n      fo = fo.filter(option => !shouldHideOption(option));\n    }\n    return fo;\n  };\n\n  // no export\n  const optionsToArray = options => {\n    let uo = options;\n\n    // Transforming an object to an array of objects\n    if (isObject(uo)) {\n      uo = Object.keys(uo).map(key => {\n        let val = uo[key];\n        return {\n          [valueProp.value]: key,\n          [trackBy.value]: val,\n          [label.value]: val\n        };\n      });\n    }\n\n    // Transforming an plain arrays to an array of objects\n    uo = uo.map(val => {\n      return typeof val === 'object' ? val : {\n        [valueProp.value]: val,\n        [trackBy.value]: val,\n        [label.value]: val\n      };\n    });\n    return uo;\n  };\n\n  // no export\n  const initInternalValue = () => {\n    if (!isNullish(ev.value)) {\n      iv.value = makeInternal(ev.value);\n    }\n  };\n  const resolveOptions = callback => {\n    resolving.value = true;\n    return new Promise((resolve, reject) => {\n      options.value(search.value, $this).then(response => {\n        ro.value = response || [];\n        if (typeof callback == 'function') {\n          callback(response);\n        }\n        resolving.value = false;\n      }).catch(e => {\n        console.error(e);\n        ro.value = [];\n        resolving.value = false;\n      }).finally(() => {\n        resolve();\n      });\n    });\n  };\n\n  // no export\n  const refreshLabels = () => {\n    if (!hasSelected.value) {\n      return;\n    }\n    if (mode.value === 'single') {\n      let option = getOption(iv.value[valueProp.value]);\n\n      /* istanbul ignore else */\n      if (option !== undefined) {\n        let newLabel = option[label.value];\n        iv.value[label.value] = newLabel;\n        if (object.value) {\n          ev.value[label.value] = newLabel;\n        }\n      }\n    } else {\n      iv.value.forEach((val, i) => {\n        let option = getOption(iv.value[i][valueProp.value]);\n\n        /* istanbul ignore else */\n        if (option !== undefined) {\n          let newLabel = option[label.value];\n          iv.value[i][label.value] = newLabel;\n          if (object.value) {\n            ev.value[i][label.value] = newLabel;\n          }\n        }\n      });\n    }\n  };\n  const refreshOptions = callback => {\n    resolveOptions(callback);\n  };\n\n  // no export\n  const makeInternal = val => {\n    if (isNullish(val)) {\n      return mode.value === 'single' ? {} : [];\n    }\n    if (object.value) {\n      return val;\n    }\n\n    // If external should be plain transform value object to plain values\n    return mode.value === 'single' ? getOption(val) || (allowAbsent.value ? {\n      [label.value]: val,\n      [valueProp.value]: val,\n      [trackBy.value]: val\n    } : {}) : val.filter(v => !!getOption(v) || allowAbsent.value).map(v => getOption(v) || {\n      [label.value]: v,\n      [valueProp.value]: v,\n      [trackBy.value]: v\n    });\n  };\n\n  // no export\n  const initSearchWatcher = () => {\n    searchWatcher.value = (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(search, query => {\n      if (query.length < minChars.value || !query && minChars.value !== 0) {\n        return;\n      }\n      resolving.value = true;\n      if (clearOnSearch.value) {\n        ro.value = [];\n      }\n      setTimeout(() => {\n        if (query != search.value) {\n          return;\n        }\n        options.value(search.value, $this).then(response => {\n          if (query == search.value || !search.value) {\n            ro.value = response;\n            pointer.value = fo.value.filter(o => o[disabledProp.value] !== true)[0] || null;\n            resolving.value = false;\n          }\n        }).catch( /* istanbul ignore next */e => {\n          console.error(e);\n        });\n      }, delay.value);\n    }, {\n      flush: 'sync'\n    });\n  };\n\n  // ================ HOOKS ===============\n\n  if (mode.value !== 'single' && !isNullish(ev.value) && !Array.isArray(ev.value)) {\n    throw new Error(`v-model must be an array when using \"${mode.value}\" mode`);\n  }\n  if (options && typeof options.value == 'function') {\n    if (resolveOnLoad.value) {\n      resolveOptions(initInternalValue);\n    } else if (object.value == true) {\n      initInternalValue();\n    }\n  } else {\n    ro.value = options.value;\n    initInternalValue();\n  }\n\n  // ============== WATCHERS ==============\n\n  if (delay.value > -1) {\n    initSearchWatcher();\n  }\n  (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(delay, (value, old) => {\n    /* istanbul ignore else */\n    if (searchWatcher.value) {\n      searchWatcher.value();\n    }\n    if (value >= 0) {\n      initSearchWatcher();\n    }\n  });\n  (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(ev, newValue => {\n    if (isNullish(newValue)) {\n      update(makeInternal(newValue), false);\n      return;\n    }\n    switch (mode.value) {\n      case 'single':\n        if (object.value ? newValue[valueProp.value] != iv.value[valueProp.value] : newValue != iv.value[valueProp.value]) {\n          update(makeInternal(newValue), false);\n        }\n        break;\n      case 'multiple':\n      case 'tags':\n        if (!arraysEqual(object.value ? newValue.map(o => o[valueProp.value]) : newValue, iv.value.map(o => o[valueProp.value]))) {\n          update(makeInternal(newValue), false);\n        }\n        break;\n    }\n  }, {\n    deep: true\n  });\n  (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(options, (n, o) => {\n    if (typeof props.options === 'function') {\n      if (resolveOnLoad.value && (!o || n && n.toString() !== o.toString())) {\n        resolveOptions();\n      }\n    } else {\n      ro.value = props.options;\n      if (!Object.keys(iv.value).length) {\n        initInternalValue();\n      }\n      refreshLabels();\n    }\n  });\n  (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(label, refreshLabels);\n  return {\n    pfo,\n    fo,\n    filteredOptions: fo,\n    hasSelected,\n    multipleLabelText,\n    eo,\n    extendedOptions: eo,\n    eg,\n    extendedGroups: eg,\n    fg,\n    filteredGroups: fg,\n    noOptions,\n    noResults,\n    resolving,\n    busy,\n    offset,\n    select,\n    deselect,\n    remove,\n    selectAll,\n    clear,\n    isSelected,\n    isDisabled,\n    isMax,\n    getOption,\n    handleOptionClick,\n    handleGroupClick,\n    handleTagRemove,\n    refreshOptions,\n    resolveOptions,\n    refreshLabels\n  };\n}\nfunction usePointer(props, context, dep) {\n  const {\n    valueProp,\n    showOptions,\n    searchable,\n    groupLabel,\n    groups: groupped,\n    mode,\n    groupSelect,\n    disabledProp,\n    groupOptions\n  } = (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRefs)(props);\n\n  // ============ DEPENDENCIES ============\n\n  const fo = dep.fo;\n  const fg = dep.fg;\n  const handleOptionClick = dep.handleOptionClick;\n  const handleGroupClick = dep.handleGroupClick;\n  const search = dep.search;\n  const pointer = dep.pointer;\n  const setPointer = dep.setPointer;\n  const clearPointer = dep.clearPointer;\n  const multiselect = dep.multiselect;\n  const isOpen = dep.isOpen;\n\n  // ============== COMPUTED ==============\n\n  // no export\n  const options = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return fo.value.filter(o => !o[disabledProp.value]);\n  });\n  const groups = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return fg.value.filter(g => !g[disabledProp.value]);\n  });\n  const canPointGroups = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return mode.value !== 'single' && groupSelect.value;\n  });\n  const isPointerGroup = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return pointer.value && pointer.value.group;\n  });\n  const currentGroup = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return getParentGroup(pointer.value);\n  });\n  const prevGroup = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    const group = isPointerGroup.value ? pointer.value : /* istanbul ignore next */getParentGroup(pointer.value);\n    const groupIndex = groups.value.map(g => g[groupLabel.value]).indexOf(group[groupLabel.value]);\n    let prevGroup = groups.value[groupIndex - 1];\n    if (prevGroup === undefined) {\n      prevGroup = lastGroup.value;\n    }\n    return prevGroup;\n  });\n  const nextGroup = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    let nextIndex = groups.value.map(g => g.label).indexOf(isPointerGroup.value ? pointer.value[groupLabel.value] : getParentGroup(pointer.value)[groupLabel.value]) + 1;\n    if (groups.value.length <= nextIndex) {\n      nextIndex = 0;\n    }\n    return groups.value[nextIndex];\n  });\n  const lastGroup = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return [...groups.value].slice(-1)[0];\n  });\n  const currentGroupFirstEnabledOption = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return pointer.value.__VISIBLE__.filter(o => !o[disabledProp.value])[0];\n  });\n  const currentGroupPrevEnabledOption = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    const options = currentGroup.value.__VISIBLE__.filter(o => !o[disabledProp.value]);\n    return options[options.map(o => o[valueProp.value]).indexOf(pointer.value[valueProp.value]) - 1];\n  });\n  const currentGroupNextEnabledOption = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    const options = getParentGroup(pointer.value).__VISIBLE__.filter(o => !o[disabledProp.value]);\n    return options[options.map(o => o[valueProp.value]).indexOf(pointer.value[valueProp.value]) + 1];\n  });\n  const prevGroupLastEnabledOption = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return [...prevGroup.value.__VISIBLE__.filter(o => !o[disabledProp.value])].slice(-1)[0];\n  });\n  const lastGroupLastEnabledOption = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return [...lastGroup.value.__VISIBLE__.filter(o => !o[disabledProp.value])].slice(-1)[0];\n  });\n\n  // =============== METHODS ==============\n\n  const isPointed = option => {\n    return !!pointer.value && (!option.group && pointer.value[valueProp.value] === option[valueProp.value] || option.group !== undefined && pointer.value[groupLabel.value] === option[groupLabel.value]) ? true : undefined;\n  };\n  const setPointerFirst = () => {\n    setPointer(options.value[0] || null);\n  };\n  const selectPointer = () => {\n    if (!pointer.value || pointer.value[disabledProp.value] === true) {\n      return;\n    }\n    if (isPointerGroup.value) {\n      handleGroupClick(pointer.value);\n    } else {\n      handleOptionClick(pointer.value);\n    }\n  };\n  const forwardPointer = () => {\n    if (pointer.value === null) {\n      setPointer((groupped.value && canPointGroups.value ? !groups.value[0].__CREATE__ ? groups.value[0] : options.value[0] : options.value[0]) || null);\n    } else if (groupped.value && canPointGroups.value) {\n      let nextPointer = isPointerGroup.value ? currentGroupFirstEnabledOption.value : currentGroupNextEnabledOption.value;\n      if (nextPointer === undefined) {\n        nextPointer = nextGroup.value;\n        if (nextPointer.__CREATE__) {\n          nextPointer = nextPointer[groupOptions.value][0];\n        }\n      }\n      setPointer(nextPointer || /* istanbul ignore next */null);\n    } else {\n      let next = options.value.map(o => o[valueProp.value]).indexOf(pointer.value[valueProp.value]) + 1;\n      if (options.value.length <= next) {\n        next = 0;\n      }\n      setPointer(options.value[next] || null);\n    }\n    (0,vue__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => {\n      adjustWrapperScrollToPointer();\n    });\n  };\n  const backwardPointer = () => {\n    if (pointer.value === null) {\n      let prevPointer = options.value[options.value.length - 1];\n      if (groupped.value && canPointGroups.value) {\n        prevPointer = lastGroupLastEnabledOption.value;\n        if (prevPointer === undefined) {\n          prevPointer = lastGroup.value;\n        }\n      }\n      setPointer(prevPointer || null);\n    } else if (groupped.value && canPointGroups.value) {\n      let prevPointer = isPointerGroup.value ? prevGroupLastEnabledOption.value : currentGroupPrevEnabledOption.value;\n      if (prevPointer === undefined) {\n        prevPointer = isPointerGroup.value ? prevGroup.value : currentGroup.value;\n        if (prevPointer.__CREATE__) {\n          prevPointer = prevGroupLastEnabledOption.value;\n          if (prevPointer === undefined) {\n            prevPointer = prevGroup.value;\n          }\n        }\n      }\n      setPointer(prevPointer || /* istanbul ignore next */null);\n    } else {\n      let prevIndex = options.value.map(o => o[valueProp.value]).indexOf(pointer.value[valueProp.value]) - 1;\n      if (prevIndex < 0) {\n        prevIndex = options.value.length - 1;\n      }\n      setPointer(options.value[prevIndex] || null);\n    }\n    (0,vue__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => {\n      adjustWrapperScrollToPointer();\n    });\n  };\n  const getParentGroup = option => {\n    return groups.value.find(group => {\n      return group.__VISIBLE__.map(o => o[valueProp.value]).indexOf(option[valueProp.value]) !== -1;\n    });\n  };\n\n  // no export\n  /* istanbul ignore next */\n  const adjustWrapperScrollToPointer = () => {\n    let pointedOption = multiselect.value.querySelector(`[data-pointed]`);\n    if (!pointedOption) {\n      return;\n    }\n    let wrapper = pointedOption.parentElement.parentElement;\n    if (groupped.value) {\n      wrapper = isPointerGroup.value ? pointedOption.parentElement.parentElement.parentElement : pointedOption.parentElement.parentElement.parentElement.parentElement;\n    }\n    if (pointedOption.offsetTop + pointedOption.offsetHeight > wrapper.clientHeight + wrapper.scrollTop) {\n      wrapper.scrollTop = pointedOption.offsetTop + pointedOption.offsetHeight - wrapper.clientHeight;\n    }\n    if (pointedOption.offsetTop < wrapper.scrollTop) {\n      wrapper.scrollTop = pointedOption.offsetTop;\n    }\n  };\n\n  // ============== WATCHERS ==============\n\n  (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(search, val => {\n    if (searchable.value) {\n      if (val.length && showOptions.value) {\n        setPointerFirst();\n      } else {\n        clearPointer();\n      }\n    }\n  });\n  (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(isOpen, val => {\n    if (val) {\n      let firstSelected = multiselect.value.querySelectorAll(`[data-selected]`)[0];\n      if (!firstSelected) {\n        return;\n      }\n      let wrapper = firstSelected.parentElement.parentElement;\n      (0,vue__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => {\n        /* istanbul ignore next */\n        if (wrapper.scrollTop > 0) {\n          return;\n        }\n        wrapper.scrollTop = firstSelected.offsetTop;\n      });\n    }\n  });\n  return {\n    pointer,\n    canPointGroups,\n    isPointed,\n    setPointerFirst,\n    selectPointer,\n    forwardPointer,\n    backwardPointer\n  };\n}\nfunction useDropdown(props, context, dep) {\n  const {\n    disabled\n  } = (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRefs)(props);\n  const $this = (0,vue__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance)().proxy;\n\n  // ================ DATA ================\n\n  const isOpen = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n\n  // =============== METHODS ==============\n\n  const open = () => {\n    if (isOpen.value || disabled.value) {\n      return;\n    }\n    isOpen.value = true;\n    context.emit('open', $this);\n  };\n  const close = () => {\n    if (!isOpen.value) {\n      return;\n    }\n    isOpen.value = false;\n    context.emit('close', $this);\n  };\n  return {\n    isOpen,\n    open,\n    close\n  };\n}\nfunction useMultiselect(props, context, dep) {\n  const {\n    searchable,\n    disabled,\n    clearOnBlur\n  } = (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRefs)(props);\n\n  // ============ DEPENDENCIES ============\n\n  const input = dep.input;\n  const open = dep.open;\n  const close = dep.close;\n  const clearSearch = dep.clearSearch;\n  const isOpen = dep.isOpen;\n\n  // ================ DATA ================\n\n  const multiselect = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const wrapper = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const tags = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const isActive = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const mouseClicked = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n\n  // ============== COMPUTED ==============\n\n  const tabindex = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return searchable.value || disabled.value ? -1 : 0;\n  });\n\n  // =============== METHODS ==============\n\n  const blur = () => {\n    if (searchable.value) {\n      input.value.blur();\n    }\n    wrapper.value.blur();\n  };\n  const focus = () => {\n    if (searchable.value && !disabled.value) {\n      input.value.focus();\n    }\n  };\n  const activate = (shouldOpen = true) => {\n    if (disabled.value) {\n      return;\n    }\n    isActive.value = true;\n    if (shouldOpen) {\n      open();\n    }\n  };\n  const deactivate = () => {\n    isActive.value = false;\n    setTimeout(() => {\n      if (!isActive.value) {\n        close();\n        if (clearOnBlur.value) {\n          clearSearch();\n        }\n      }\n    }, 1);\n  };\n  const handleFocusIn = e => {\n    if (e.target.closest('[data-tags]') && e.target.nodeName !== 'INPUT' || e.target.closest('[data-clear]')) {\n      return;\n    }\n    activate(mouseClicked.value);\n  };\n  const handleFocusOut = () => {\n    deactivate();\n  };\n  const handleCaretClick = () => {\n    deactivate();\n    blur();\n  };\n\n  /* istanbul ignore next */\n  const handleMousedown = e => {\n    mouseClicked.value = true;\n    if (isOpen.value && (e.target.isEqualNode(wrapper.value) || e.target.isEqualNode(tags.value))) {\n      setTimeout(() => {\n        deactivate();\n      }, 0);\n    } else if (document.activeElement.isEqualNode(wrapper.value) && !isOpen.value) {\n      activate();\n    }\n    setTimeout(() => {\n      mouseClicked.value = false;\n    }, 0);\n  };\n  return {\n    multiselect,\n    wrapper,\n    tags,\n    tabindex,\n    isActive,\n    mouseClicked,\n    blur,\n    focus,\n    activate,\n    deactivate,\n    handleFocusIn,\n    handleFocusOut,\n    handleCaretClick,\n    handleMousedown\n  };\n}\nfunction useKeyboard(props, context, dep) {\n  const {\n    mode,\n    addTagOn,\n    openDirection,\n    searchable,\n    showOptions,\n    valueProp,\n    groups: groupped,\n    addOptionOn: addOptionOn_,\n    createTag,\n    createOption: createOption_,\n    reverse\n  } = (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRefs)(props);\n  const $this = (0,vue__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance)().proxy;\n\n  // ============ DEPENDENCIES ============\n\n  const iv = dep.iv;\n  const update = dep.update;\n  const search = dep.search;\n  const setPointer = dep.setPointer;\n  const selectPointer = dep.selectPointer;\n  const backwardPointer = dep.backwardPointer;\n  const forwardPointer = dep.forwardPointer;\n  const multiselect = dep.multiselect;\n  const wrapper = dep.wrapper;\n  const tags = dep.tags;\n  const isOpen = dep.isOpen;\n  const open = dep.open;\n  const blur = dep.blur;\n  const fo = dep.fo;\n\n  // ============== COMPUTED ==============\n\n  // no export\n  const createOption = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return createTag.value || createOption_.value || false;\n  });\n\n  // no export\n  const addOptionOn = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (addTagOn.value !== undefined) {\n      return addTagOn.value;\n    } else if (addOptionOn_.value !== undefined) {\n      return addOptionOn_.value;\n    }\n    return ['enter'];\n  });\n\n  // =============== METHODS ==============\n\n  // no export\n  const preparePointer = () => {\n    // When options are hidden and creating tags is allowed\n    // no pointer will be set (because options are hidden).\n    // In such case we need to set the pointer manually to the \n    // first option, which equals to the option created from\n    // the search value.\n    if (mode.value === 'tags' && !showOptions.value && createOption.value && searchable.value && !groupped.value) {\n      setPointer(fo.value[fo.value.map(o => o[valueProp.value]).indexOf(search.value)]);\n    }\n  };\n  const removeLastRemovable = arr => {\n    // Find the index of the last object in the array that doesn't have a \"remove\" property set to false\n    let indexToRemove = arr.length - 1;\n    while (indexToRemove >= 0 && (arr[indexToRemove].remove === false || arr[indexToRemove].disabled)) {\n      indexToRemove--;\n    }\n\n    // If all objects have a \"remove\" property set to false, don't remove anything and return the original array\n    if (indexToRemove < 0) {\n      return arr;\n    }\n\n    // Remove the object at the found index and return the updated array\n    arr.splice(indexToRemove, 1);\n    return arr;\n  };\n  const handleKeydown = e => {\n    context.emit('keydown', e, $this);\n    let tagList;\n    let activeIndex;\n    if (['ArrowLeft', 'ArrowRight', 'Enter'].indexOf(e.key) !== -1 && mode.value === 'tags') {\n      tagList = [...multiselect.value.querySelectorAll(`[data-tags] > *`)].filter(e => e !== tags.value);\n      activeIndex = tagList.findIndex(e => e === document.activeElement);\n    }\n    switch (e.key) {\n      case 'Backspace':\n        if (mode.value === 'single') {\n          return;\n        }\n        if (searchable.value && [null, ''].indexOf(search.value) === -1) {\n          return;\n        }\n        if (iv.value.length === 0) {\n          return;\n        }\n        update(removeLastRemovable([...iv.value]));\n        break;\n      case 'Enter':\n        e.preventDefault();\n        if (e.keyCode === 229) {\n          // ignore IME confirmation\n          return;\n        }\n        if (activeIndex !== -1 && activeIndex !== undefined) {\n          update([...iv.value].filter((v, k) => k !== activeIndex));\n          if (activeIndex === tagList.length - 1) {\n            if (tagList.length - 1) {\n              tagList[tagList.length - 2].focus();\n            } else if (searchable.value) {\n              tags.value.querySelector('input').focus();\n            } else {\n              wrapper.value.focus();\n            }\n          }\n          return;\n        }\n        if (addOptionOn.value.indexOf('enter') === -1 && createOption.value) {\n          return;\n        }\n        preparePointer();\n        selectPointer();\n        break;\n      case ' ':\n        if (!createOption.value && !searchable.value) {\n          e.preventDefault();\n          preparePointer();\n          selectPointer();\n          return;\n        }\n        if (!createOption.value) {\n          return false;\n        }\n        if (addOptionOn.value.indexOf('space') === -1 && createOption.value) {\n          return;\n        }\n        e.preventDefault();\n        preparePointer();\n        selectPointer();\n        break;\n      case 'Tab':\n      case ';':\n      case ',':\n        if (addOptionOn.value.indexOf(e.key.toLowerCase()) === -1 || !createOption.value) {\n          return;\n        }\n        preparePointer();\n        selectPointer();\n        e.preventDefault();\n        break;\n      case 'Escape':\n        blur();\n        break;\n      case 'ArrowUp':\n        e.preventDefault();\n        if (!showOptions.value) {\n          return;\n        }\n\n        /* istanbul ignore else */\n        if (!isOpen.value) {\n          open();\n        }\n        backwardPointer();\n        break;\n      case 'ArrowDown':\n        e.preventDefault();\n        if (!showOptions.value) {\n          return;\n        }\n\n        /* istanbul ignore else */\n        if (!isOpen.value) {\n          open();\n        }\n        forwardPointer();\n        break;\n      case 'ArrowLeft':\n        if (searchable.value && tags.value && tags.value.querySelector('input').selectionStart || e.shiftKey || mode.value !== 'tags' || !iv.value || !iv.value.length) {\n          return;\n        }\n        e.preventDefault();\n        if (activeIndex === -1) {\n          tagList[tagList.length - 1].focus();\n        } else if (activeIndex > 0) {\n          tagList[activeIndex - 1].focus();\n        }\n        break;\n      case 'ArrowRight':\n        if (activeIndex === -1 || e.shiftKey || mode.value !== 'tags' || !iv.value || !iv.value.length) {\n          return;\n        }\n        e.preventDefault();\n\n        /* istanbul ignore else */\n        if (tagList.length > activeIndex + 1) {\n          tagList[activeIndex + 1].focus();\n        } else if (searchable.value) {\n          tags.value.querySelector('input').focus();\n        } else if (!searchable.value) {\n          wrapper.value.focus();\n        }\n        break;\n    }\n  };\n  const handleKeyup = e => {\n    context.emit('keyup', e, $this);\n  };\n  return {\n    handleKeydown,\n    handleKeyup,\n    preparePointer\n  };\n}\nfunction useClasses(props, context, dependencies) {\n  const {\n    classes: classes_,\n    disabled,\n    openDirection,\n    showOptions\n  } = (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRefs)(props);\n\n  // ============ DEPENDENCIES ============\n\n  const isOpen = dependencies.isOpen;\n  const isPointed = dependencies.isPointed;\n  const isSelected = dependencies.isSelected;\n  const isDisabled = dependencies.isDisabled;\n  const isActive = dependencies.isActive;\n  const canPointGroups = dependencies.canPointGroups;\n  const resolving = dependencies.resolving;\n  const fo = dependencies.fo;\n  const classes = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => ({\n    container: 'multiselect',\n    containerDisabled: 'is-disabled',\n    containerOpen: 'is-open',\n    containerOpenTop: 'is-open-top',\n    containerActive: 'is-active',\n    wrapper: 'multiselect-wrapper',\n    singleLabel: 'multiselect-single-label',\n    singleLabelText: 'multiselect-single-label-text',\n    multipleLabel: 'multiselect-multiple-label',\n    search: 'multiselect-search',\n    tags: 'multiselect-tags',\n    tag: 'multiselect-tag',\n    tagDisabled: 'is-disabled',\n    tagRemove: 'multiselect-tag-remove',\n    tagRemoveIcon: 'multiselect-tag-remove-icon',\n    tagsSearchWrapper: 'multiselect-tags-search-wrapper',\n    tagsSearch: 'multiselect-tags-search',\n    tagsSearchCopy: 'multiselect-tags-search-copy',\n    placeholder: 'multiselect-placeholder',\n    caret: 'multiselect-caret',\n    caretOpen: 'is-open',\n    clear: 'multiselect-clear',\n    clearIcon: 'multiselect-clear-icon',\n    spinner: 'multiselect-spinner',\n    inifinite: 'multiselect-inifite',\n    inifiniteSpinner: 'multiselect-inifite-spinner',\n    dropdown: 'multiselect-dropdown',\n    dropdownTop: 'is-top',\n    dropdownHidden: 'is-hidden',\n    options: 'multiselect-options',\n    optionsTop: 'is-top',\n    group: 'multiselect-group',\n    groupLabel: 'multiselect-group-label',\n    groupLabelPointable: 'is-pointable',\n    groupLabelPointed: 'is-pointed',\n    groupLabelSelected: 'is-selected',\n    groupLabelDisabled: 'is-disabled',\n    groupLabelSelectedPointed: 'is-selected is-pointed',\n    groupLabelSelectedDisabled: 'is-selected is-disabled',\n    groupOptions: 'multiselect-group-options',\n    option: 'multiselect-option',\n    optionPointed: 'is-pointed',\n    optionSelected: 'is-selected',\n    optionDisabled: 'is-disabled',\n    optionSelectedPointed: 'is-selected is-pointed',\n    optionSelectedDisabled: 'is-selected is-disabled',\n    noOptions: 'multiselect-no-options',\n    noResults: 'multiselect-no-results',\n    fakeInput: 'multiselect-fake-input',\n    assist: 'multiselect-assistive-text',\n    spacer: 'multiselect-spacer',\n    ...classes_.value\n  }));\n\n  // ============== COMPUTED ==============\n\n  const showDropdown = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return !!(isOpen.value && showOptions.value && (!resolving.value || resolving.value && fo.value.length));\n  });\n  const classList = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    const c = classes.value;\n    return {\n      container: [c.container].concat(disabled.value ? c.containerDisabled : []).concat(showDropdown.value && openDirection.value === 'top' ? c.containerOpenTop : []).concat(showDropdown.value && openDirection.value !== 'top' ? c.containerOpen : []).concat(isActive.value ? c.containerActive : []),\n      wrapper: c.wrapper,\n      spacer: c.spacer,\n      singleLabel: c.singleLabel,\n      singleLabelText: c.singleLabelText,\n      multipleLabel: c.multipleLabel,\n      search: c.search,\n      tags: c.tags,\n      tag: [c.tag].concat(disabled.value ? c.tagDisabled : []),\n      tagDisabled: c.tagDisabled,\n      tagRemove: c.tagRemove,\n      tagRemoveIcon: c.tagRemoveIcon,\n      tagsSearchWrapper: c.tagsSearchWrapper,\n      tagsSearch: c.tagsSearch,\n      tagsSearchCopy: c.tagsSearchCopy,\n      placeholder: c.placeholder,\n      caret: [c.caret].concat(isOpen.value ? c.caretOpen : []),\n      clear: c.clear,\n      clearIcon: c.clearIcon,\n      spinner: c.spinner,\n      inifinite: c.inifinite,\n      inifiniteSpinner: c.inifiniteSpinner,\n      dropdown: [c.dropdown].concat(openDirection.value === 'top' ? c.dropdownTop : []).concat(!isOpen.value || !showOptions.value || !showDropdown.value ? c.dropdownHidden : []),\n      options: [c.options].concat(openDirection.value === 'top' ? c.optionsTop : []),\n      group: c.group,\n      groupLabel: g => {\n        let groupLabel = [c.groupLabel];\n        if (isPointed(g)) {\n          groupLabel.push(isSelected(g) ? c.groupLabelSelectedPointed : c.groupLabelPointed);\n        } else if (isSelected(g) && canPointGroups.value) {\n          groupLabel.push(isDisabled(g) ? c.groupLabelSelectedDisabled : c.groupLabelSelected);\n        } else if (isDisabled(g)) {\n          groupLabel.push(c.groupLabelDisabled);\n        }\n        if (canPointGroups.value) {\n          groupLabel.push(c.groupLabelPointable);\n        }\n        return groupLabel;\n      },\n      groupOptions: c.groupOptions,\n      option: (o, g) => {\n        let option = [c.option];\n        if (isPointed(o)) {\n          option.push(isSelected(o) ? c.optionSelectedPointed : c.optionPointed);\n        } else if (isSelected(o)) {\n          option.push(isDisabled(o) ? c.optionSelectedDisabled : c.optionSelected);\n        } else if (isDisabled(o) || g && isDisabled(g)) {\n          option.push(c.optionDisabled);\n        }\n        return option;\n      },\n      noOptions: c.noOptions,\n      noResults: c.noResults,\n      assist: c.assist,\n      fakeInput: c.fakeInput\n    };\n  });\n  return {\n    classList,\n    showDropdown\n  };\n}\nfunction useScroll(props, context, dep) {\n  const {\n    limit,\n    infinite\n  } = (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRefs)(props);\n\n  // ============ DEPENDENCIES ============\n\n  const isOpen = dep.isOpen;\n  const offset = dep.offset;\n  const search = dep.search;\n  const pfo = dep.pfo;\n  const eo = dep.eo;\n\n  // ================ DATA ================\n\n  // no export\n  const observer = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const infiniteLoader = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n\n  // ============== COMPUTED ==============\n\n  const hasMore = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return offset.value < pfo.value.length;\n  });\n\n  // =============== METHODS ==============\n\n  // no export\n  /* istanbul ignore next */\n  const handleIntersectionObserver = entries => {\n    const {\n      isIntersecting,\n      target\n    } = entries[0];\n    if (isIntersecting) {\n      const parent = target.offsetParent;\n      const scrollTop = parent.scrollTop;\n      offset.value += limit.value == -1 ? 10 : limit.value;\n      (0,vue__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => {\n        parent.scrollTop = scrollTop;\n      });\n    }\n  };\n  const observe = () => {\n    /* istanbul ignore else */\n    if (isOpen.value && offset.value < pfo.value.length) {\n      observer.value.observe(infiniteLoader.value);\n    } else if (!isOpen.value && observer.value) {\n      observer.value.disconnect();\n    }\n  };\n\n  // ============== WATCHERS ==============\n\n  (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(isOpen, () => {\n    if (!infinite.value) {\n      return;\n    }\n    observe();\n  });\n  (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(search, () => {\n    if (!infinite.value) {\n      return;\n    }\n    offset.value = limit.value;\n    observe();\n  }, {\n    flush: 'post'\n  });\n  (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(eo, () => {\n    if (!infinite.value) {\n      return;\n    }\n    observe();\n  }, {\n    immediate: false,\n    flush: 'post'\n  });\n\n  // ================ HOOKS ===============\n\n  (0,vue__WEBPACK_IMPORTED_MODULE_1__.onMounted)(() => {\n    /* istanbul ignore else */\n    if (window && window.IntersectionObserver) {\n      observer.value = new IntersectionObserver(handleIntersectionObserver);\n    }\n  });\n  return {\n    hasMore,\n    infiniteLoader\n  };\n}\nfunction useA11y(props, context, dep) {\n  const {\n    placeholder,\n    id,\n    valueProp,\n    label: labelProp,\n    mode,\n    groupLabel,\n    aria,\n    searchable\n  } = (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRefs)(props);\n\n  // ============ DEPENDENCIES ============\n\n  const pointer = dep.pointer;\n  const iv = dep.iv;\n  const hasSelected = dep.hasSelected;\n  const multipleLabelText = dep.multipleLabelText;\n\n  // ================ DATA ================\n\n  const label = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n\n  // ============== COMPUTED ==============\n\n  const ariaAssist = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    let texts = [];\n    if (id && id.value) {\n      texts.push(id.value);\n    }\n    texts.push('assist');\n    return texts.join('-');\n  });\n  const ariaControls = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    let texts = [];\n    if (id && id.value) {\n      texts.push(id.value);\n    }\n    texts.push('multiselect-options');\n    return texts.join('-');\n  });\n  const ariaActiveDescendant = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    let texts = [];\n    if (id && id.value) {\n      texts.push(id.value);\n    }\n    if (pointer.value) {\n      texts.push(pointer.value.group ? 'multiselect-group' : 'multiselect-option');\n      texts.push(pointer.value.group ? pointer.value.index : pointer.value[valueProp.value]);\n      return texts.join('-');\n    }\n  });\n  const ariaPlaceholder = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return placeholder.value;\n  });\n  const ariaMultiselectable = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return mode.value !== 'single';\n  });\n  const ariaLabel = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    let ariaLabel = '';\n    if (mode.value === 'single' && hasSelected.value) {\n      ariaLabel += iv.value[labelProp.value];\n    }\n    if (mode.value === 'multiple' && hasSelected.value) {\n      ariaLabel += multipleLabelText.value;\n    }\n    if (mode.value === 'tags' && hasSelected.value) {\n      ariaLabel += iv.value.map(v => v[labelProp.value]).join(', ');\n    }\n    return ariaLabel;\n  });\n  const arias = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    let arias = {\n      ...aria.value\n    };\n\n    // Need to add manually because focusing\n    // the input won't read the selected value\n    if (searchable.value) {\n      arias['aria-labelledby'] = arias['aria-labelledby'] ? `${ariaAssist.value} ${arias['aria-labelledby']}` : ariaAssist.value;\n      if (ariaLabel.value && arias['aria-label']) {\n        arias['aria-label'] = `${ariaLabel.value}, ${arias['aria-label']}`;\n      }\n    }\n    return arias;\n  });\n\n  // =============== METHODS ==============\n\n  const ariaOptionId = option => {\n    let texts = [];\n    if (id && id.value) {\n      texts.push(id.value);\n    }\n    texts.push('multiselect-option');\n    texts.push(option[valueProp.value]);\n    return texts.join('-');\n  };\n  const ariaGroupId = option => {\n    let texts = [];\n    if (id && id.value) {\n      texts.push(id.value);\n    }\n    texts.push('multiselect-group');\n    texts.push(option.index);\n    return texts.join('-');\n  };\n  const ariaOptionLabel = label => {\n    let texts = [];\n    texts.push(label);\n    return texts.join(' ');\n  };\n  const ariaGroupLabel = label => {\n    let texts = [];\n    texts.push(label);\n    return texts.join(' ');\n  };\n  const ariaTagLabel = label => {\n    return `${label} ❎`;\n  };\n\n  // =============== HOOKS ================\n\n  (0,vue__WEBPACK_IMPORTED_MODULE_1__.onMounted)(() => {\n    /* istanbul ignore next */\n    if (id && id.value && document && document.querySelector) {\n      let forTag = document.querySelector(`[for=\"${id.value}\"]`);\n      label.value = forTag ? forTag.innerText : null;\n    }\n  });\n  return {\n    arias,\n    ariaLabel,\n    ariaAssist,\n    ariaControls,\n    ariaPlaceholder,\n    ariaMultiselectable,\n    ariaActiveDescendant,\n    ariaOptionId,\n    ariaOptionLabel,\n    ariaGroupId,\n    ariaGroupLabel,\n    ariaTagLabel\n  };\n}\nfunction useI18n(props, context, dep) {\n  const {\n    locale,\n    fallbackLocale\n  } = (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRefs)(props);\n\n  // =============== METHODS ==============\n\n  const localize = target => {\n    if (!target || typeof target !== 'object') {\n      return target;\n    }\n    if (target && target[locale.value]) {\n      return target[locale.value];\n    } else if (target && locale.value && target[locale.value.toUpperCase()]) {\n      return target[locale.value.toUpperCase()];\n    } else if (target && target[fallbackLocale.value]) {\n      return target[fallbackLocale.value];\n    } else if (target && fallbackLocale.value && target[fallbackLocale.value.toUpperCase()]) {\n      return target[fallbackLocale.value.toUpperCase()];\n    } else if (target && Object.keys(target)[0]) {\n      return target[Object.keys(target)[0]];\n    } else {\n      return '';\n    }\n  };\n  return {\n    localize\n  };\n}\nfunction resolveDeps(props, context, features, deps = {}) {\n  features.forEach(composable => {\n    /* istanbul ignore else */\n    if (composable) {\n      deps = {\n        ...deps,\n        ...composable(props, context, deps)\n      };\n    }\n  });\n  return deps;\n}\nvar script = {\n  name: 'Multiselect',\n  emits: ['paste', 'open', 'close', 'select', 'deselect', 'input', 'search-change', 'tag', 'option', 'update:modelValue', 'change', 'clear', 'keydown', 'keyup', 'max', 'create'],\n  props: {\n    value: {\n      required: false\n    },\n    modelValue: {\n      required: false\n    },\n    options: {\n      type: [Array, Object, Function],\n      required: false,\n      default: () => []\n    },\n    id: {\n      type: [String, Number],\n      required: false\n    },\n    name: {\n      type: [String, Number],\n      required: false,\n      default: 'multiselect'\n    },\n    disabled: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    label: {\n      type: String,\n      required: false,\n      default: 'label'\n    },\n    trackBy: {\n      type: String,\n      required: false,\n      default: undefined\n    },\n    valueProp: {\n      type: String,\n      required: false,\n      default: 'value'\n    },\n    placeholder: {\n      type: String,\n      required: false,\n      default: null\n    },\n    mode: {\n      type: String,\n      required: false,\n      default: 'single' // single|multiple|tags\n    },\n\n    searchable: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    limit: {\n      type: Number,\n      required: false,\n      default: -1\n    },\n    hideSelected: {\n      type: Boolean,\n      required: false,\n      default: true\n    },\n    createTag: {\n      type: Boolean,\n      required: false,\n      default: undefined\n    },\n    createOption: {\n      type: Boolean,\n      required: false,\n      default: undefined\n    },\n    appendNewTag: {\n      type: Boolean,\n      required: false,\n      default: undefined\n    },\n    appendNewOption: {\n      type: Boolean,\n      required: false,\n      default: undefined\n    },\n    addTagOn: {\n      type: Array,\n      required: false,\n      default: undefined\n    },\n    addOptionOn: {\n      type: Array,\n      required: false,\n      default: undefined\n    },\n    caret: {\n      type: Boolean,\n      required: false,\n      default: true\n    },\n    loading: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    noOptionsText: {\n      type: [String, Object],\n      required: false,\n      default: 'The list is empty'\n    },\n    noResultsText: {\n      type: [String, Object],\n      required: false,\n      default: 'No results found'\n    },\n    multipleLabel: {\n      type: Function,\n      required: false\n    },\n    object: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    delay: {\n      type: Number,\n      required: false,\n      default: -1\n    },\n    minChars: {\n      type: Number,\n      required: false,\n      default: 0\n    },\n    resolveOnLoad: {\n      type: Boolean,\n      required: false,\n      default: true\n    },\n    filterResults: {\n      type: Boolean,\n      required: false,\n      default: true\n    },\n    clearOnSearch: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    clearOnSelect: {\n      type: Boolean,\n      required: false,\n      default: true\n    },\n    canDeselect: {\n      type: Boolean,\n      required: false,\n      default: true\n    },\n    canClear: {\n      type: Boolean,\n      required: false,\n      default: true\n    },\n    max: {\n      type: Number,\n      required: false,\n      default: -1\n    },\n    showOptions: {\n      type: Boolean,\n      required: false,\n      default: true\n    },\n    required: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    openDirection: {\n      type: String,\n      required: false,\n      default: 'bottom'\n    },\n    nativeSupport: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    classes: {\n      type: Object,\n      required: false,\n      default: () => ({})\n    },\n    strict: {\n      type: Boolean,\n      required: false,\n      default: true\n    },\n    closeOnSelect: {\n      type: Boolean,\n      required: false,\n      default: true\n    },\n    closeOnDeselect: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    autocomplete: {\n      type: String,\n      required: false\n    },\n    groups: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    groupLabel: {\n      type: String,\n      required: false,\n      default: 'label'\n    },\n    groupOptions: {\n      type: String,\n      required: false,\n      default: 'options'\n    },\n    groupHideEmpty: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    groupSelect: {\n      type: Boolean,\n      required: false,\n      default: true\n    },\n    inputType: {\n      type: String,\n      required: false,\n      default: 'text'\n    },\n    attrs: {\n      required: false,\n      type: Object,\n      default: () => ({})\n    },\n    onCreate: {\n      required: false,\n      type: Function\n    },\n    disabledProp: {\n      type: String,\n      required: false,\n      default: 'disabled'\n    },\n    searchStart: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    reverse: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    regex: {\n      type: [Object, String, RegExp],\n      required: false,\n      default: undefined\n    },\n    rtl: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    infinite: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    aria: {\n      required: false,\n      type: Object,\n      default: () => ({})\n    },\n    clearOnBlur: {\n      required: false,\n      type: Boolean,\n      default: true\n    },\n    locale: {\n      required: false,\n      type: String,\n      default: null\n    },\n    fallbackLocale: {\n      required: false,\n      type: String,\n      default: 'en'\n    },\n    searchFilter: {\n      required: false,\n      type: Function,\n      default: null\n    },\n    allowAbsent: {\n      required: false,\n      type: Boolean,\n      default: false\n    }\n  },\n  setup(props, context) {\n    return resolveDeps(props, context, [useI18n, useValue, usePointer$1, useDropdown, useSearch, useData, useMultiselect, useOptions, useScroll, usePointer, useKeyboard, useClasses, useA11y]);\n  }\n};\nconst _hoisted_1 = [\"id\", \"dir\"];\nconst _hoisted_2 = [\"tabindex\", \"aria-controls\", \"aria-placeholder\", \"aria-expanded\", \"aria-activedescendant\", \"aria-multiselectable\", \"role\"];\nconst _hoisted_3 = [\"type\", \"modelValue\", \"value\", \"autocomplete\", \"id\", \"aria-controls\", \"aria-placeholder\", \"aria-expanded\", \"aria-activedescendant\", \"aria-multiselectable\"];\nconst _hoisted_4 = [\"onKeyup\", \"aria-label\"];\nconst _hoisted_5 = [\"onClick\"];\nconst _hoisted_6 = [\"type\", \"modelValue\", \"value\", \"id\", \"autocomplete\", \"aria-controls\", \"aria-placeholder\", \"aria-expanded\", \"aria-activedescendant\", \"aria-multiselectable\"];\nconst _hoisted_7 = [\"innerHTML\"];\nconst _hoisted_8 = [\"id\"];\nconst _hoisted_9 = [\"id\", \"aria-label\", \"aria-selected\"];\nconst _hoisted_10 = [\"data-pointed\", \"onMouseenter\", \"onClick\"];\nconst _hoisted_11 = [\"innerHTML\"];\nconst _hoisted_12 = [\"aria-label\"];\nconst _hoisted_13 = [\"data-pointed\", \"data-selected\", \"onMouseenter\", \"onClick\", \"id\", \"aria-selected\", \"aria-label\"];\nconst _hoisted_14 = [\"data-pointed\", \"data-selected\", \"onMouseenter\", \"onClick\", \"id\", \"aria-selected\", \"aria-label\"];\nconst _hoisted_15 = [\"innerHTML\"];\nconst _hoisted_16 = [\"innerHTML\"];\nconst _hoisted_17 = [\"value\"];\nconst _hoisted_18 = [\"name\", \"value\"];\nconst _hoisted_19 = [\"name\", \"value\"];\nconst _hoisted_20 = [\"id\"];\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(\"div\", {\n    ref: \"multiselect\",\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.container),\n    id: $props.searchable ? undefined : $props.id,\n    dir: $props.rtl ? 'rtl' : undefined,\n    onFocusin: _cache[10] || (_cache[10] = (...args) => _ctx.handleFocusIn && _ctx.handleFocusIn(...args)),\n    onFocusout: _cache[11] || (_cache[11] = (...args) => _ctx.handleFocusOut && _ctx.handleFocusOut(...args)),\n    onKeyup: _cache[12] || (_cache[12] = (...args) => _ctx.handleKeyup && _ctx.handleKeyup(...args)),\n    onKeydown: _cache[13] || (_cache[13] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))\n  }, [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"div\", (0,vue__WEBPACK_IMPORTED_MODULE_1__.mergeProps)({\n    class: _ctx.classList.wrapper,\n    onMousedown: _cache[9] || (_cache[9] = (...args) => _ctx.handleMousedown && _ctx.handleMousedown(...args)),\n    ref: \"wrapper\",\n    tabindex: _ctx.tabindex,\n    \"aria-controls\": !$props.searchable ? _ctx.ariaControls : undefined,\n    \"aria-placeholder\": !$props.searchable ? _ctx.ariaPlaceholder : undefined,\n    \"aria-expanded\": !$props.searchable ? _ctx.isOpen : undefined,\n    \"aria-activedescendant\": !$props.searchable ? _ctx.ariaActiveDescendant : undefined,\n    \"aria-multiselectable\": !$props.searchable ? _ctx.ariaMultiselectable : undefined,\n    role: !$props.searchable ? 'combobox' : undefined\n  }, !$props.searchable ? _ctx.arias : {}), [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\" Search \"), $props.mode !== 'tags' && $props.searchable && !$props.disabled ? ((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(\"input\", (0,vue__WEBPACK_IMPORTED_MODULE_1__.mergeProps)({\n    key: 0,\n    type: $props.inputType,\n    modelValue: _ctx.search,\n    value: _ctx.search,\n    class: _ctx.classList.search,\n    autocomplete: $props.autocomplete,\n    id: $props.searchable ? $props.id : undefined,\n    onInput: _cache[0] || (_cache[0] = (...args) => _ctx.handleSearchInput && _ctx.handleSearchInput(...args)),\n    onKeypress: _cache[1] || (_cache[1] = (...args) => _ctx.handleKeypress && _ctx.handleKeypress(...args)),\n    onPaste: _cache[2] || (_cache[2] = (0,vue__WEBPACK_IMPORTED_MODULE_1__.withModifiers)((...args) => _ctx.handlePaste && _ctx.handlePaste(...args), [\"stop\"])),\n    ref: \"input\",\n    \"aria-controls\": _ctx.ariaControls,\n    \"aria-placeholder\": _ctx.ariaPlaceholder,\n    \"aria-expanded\": _ctx.isOpen,\n    \"aria-activedescendant\": _ctx.ariaActiveDescendant,\n    \"aria-multiselectable\": _ctx.ariaMultiselectable,\n    role: \"combobox\"\n  }, {\n    ...$props.attrs,\n    ..._ctx.arias\n  }), null, 16 /* FULL_PROPS */, _hoisted_3)) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\" Tags (with search) \"), $props.mode == 'tags' ? ((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(\"div\", {\n    key: 1,\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.tags),\n    \"data-tags\": \"\"\n  }, [((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_1__.renderList)(_ctx.iv, (option, i, key) => {\n    return (0,vue__WEBPACK_IMPORTED_MODULE_1__.renderSlot)(_ctx.$slots, \"tag\", {\n      option: option,\n      handleTagRemove: _ctx.handleTagRemove,\n      disabled: $props.disabled\n    }, () => [((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(\"span\", {\n      class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([_ctx.classList.tag, option.disabled ? _ctx.classList.tagDisabled : null]),\n      tabindex: \"-1\",\n      onKeyup: (0,vue__WEBPACK_IMPORTED_MODULE_1__.withKeys)($event => _ctx.handleTagRemove(option, $event), [\"enter\"]),\n      key: key,\n      \"aria-label\": _ctx.ariaTagLabel(_ctx.localize(option[$props.label]))\n    }, [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_1__.toDisplayString)(_ctx.localize(option[$props.label])) + \" \", 1 /* TEXT */), !$props.disabled && !option.disabled ? ((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(\"span\", {\n      key: 0,\n      class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.tagRemove),\n      onClick: (0,vue__WEBPACK_IMPORTED_MODULE_1__.withModifiers)($event => _ctx.handleTagRemove(option, $event), [\"stop\"])\n    }, [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"span\", {\n      class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.tagRemoveIcon)\n    }, null, 2 /* CLASS */)], 10 /* CLASS, PROPS */, _hoisted_5)) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true)], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_4))]);\n  }), 256 /* UNKEYED_FRAGMENT */)), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"div\", {\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.tagsSearchWrapper),\n    ref: \"tags\"\n  }, [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\" Used for measuring search width \"), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"span\", {\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.tagsSearchCopy)\n  }, (0,vue__WEBPACK_IMPORTED_MODULE_1__.toDisplayString)(_ctx.search), 3 /* TEXT, CLASS */), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\" Actual search input \"), $props.searchable && !$props.disabled ? ((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(\"input\", (0,vue__WEBPACK_IMPORTED_MODULE_1__.mergeProps)({\n    key: 0,\n    type: $props.inputType,\n    modelValue: _ctx.search,\n    value: _ctx.search,\n    class: _ctx.classList.tagsSearch,\n    id: $props.searchable ? $props.id : undefined,\n    autocomplete: $props.autocomplete,\n    onInput: _cache[3] || (_cache[3] = (...args) => _ctx.handleSearchInput && _ctx.handleSearchInput(...args)),\n    onKeypress: _cache[4] || (_cache[4] = (...args) => _ctx.handleKeypress && _ctx.handleKeypress(...args)),\n    onPaste: _cache[5] || (_cache[5] = (0,vue__WEBPACK_IMPORTED_MODULE_1__.withModifiers)((...args) => _ctx.handlePaste && _ctx.handlePaste(...args), [\"stop\"])),\n    ref: \"input\",\n    \"aria-controls\": _ctx.ariaControls,\n    \"aria-placeholder\": _ctx.ariaPlaceholder,\n    \"aria-expanded\": _ctx.isOpen,\n    \"aria-activedescendant\": _ctx.ariaActiveDescendant,\n    \"aria-multiselectable\": _ctx.ariaMultiselectable,\n    role: \"combobox\"\n  }, {\n    ...$props.attrs,\n    ..._ctx.arias\n  }), null, 16 /* FULL_PROPS */, _hoisted_6)) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true)], 2 /* CLASS */)], 2 /* CLASS */)) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\" Single label \"), $props.mode == 'single' && _ctx.hasSelected && !_ctx.search && _ctx.iv ? (0,vue__WEBPACK_IMPORTED_MODULE_1__.renderSlot)(_ctx.$slots, \"singlelabel\", {\n    key: 2,\n    value: _ctx.iv\n  }, () => [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"div\", {\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.singleLabel)\n  }, [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"span\", {\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.singleLabelText)\n  }, (0,vue__WEBPACK_IMPORTED_MODULE_1__.toDisplayString)(_ctx.localize(_ctx.iv[$props.label])), 3 /* TEXT, CLASS */)], 2 /* CLASS */)]) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\" Multiple label \"), $props.mode == 'multiple' && _ctx.hasSelected && !_ctx.search ? (0,vue__WEBPACK_IMPORTED_MODULE_1__.renderSlot)(_ctx.$slots, \"multiplelabel\", {\n    key: 3,\n    values: _ctx.iv\n  }, () => [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"div\", {\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.multipleLabel),\n    innerHTML: _ctx.multipleLabelText\n  }, null, 10 /* CLASS, PROPS */, _hoisted_7)]) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\" Placeholder \"), $props.placeholder && !_ctx.hasSelected && !_ctx.search ? (0,vue__WEBPACK_IMPORTED_MODULE_1__.renderSlot)(_ctx.$slots, \"placeholder\", {\n    key: 4\n  }, () => [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"div\", {\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.placeholder),\n    \"aria-hidden\": \"true\"\n  }, (0,vue__WEBPACK_IMPORTED_MODULE_1__.toDisplayString)($props.placeholder), 3 /* TEXT, CLASS */)]) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\" Spinner \"), $props.loading || _ctx.resolving ? (0,vue__WEBPACK_IMPORTED_MODULE_1__.renderSlot)(_ctx.$slots, \"spinner\", {\n    key: 5\n  }, () => [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"span\", {\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.spinner),\n    \"aria-hidden\": \"true\"\n  }, null, 2 /* CLASS */)]) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\" Clear \"), _ctx.hasSelected && !$props.disabled && $props.canClear && !_ctx.busy ? (0,vue__WEBPACK_IMPORTED_MODULE_1__.renderSlot)(_ctx.$slots, \"clear\", {\n    key: 6,\n    clear: _ctx.clear\n  }, () => [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"span\", {\n    \"aria-hidden\": \"true\",\n    tabindex: \"0\",\n    role: \"button\",\n    \"data-clear\": \"\",\n    \"aria-roledescription\": \"❎\",\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.clear),\n    onClick: _cache[6] || (_cache[6] = (...args) => _ctx.clear && _ctx.clear(...args)),\n    onKeyup: _cache[7] || (_cache[7] = (0,vue__WEBPACK_IMPORTED_MODULE_1__.withKeys)((...args) => _ctx.clear && _ctx.clear(...args), [\"enter\"]))\n  }, [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"span\", {\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.clearIcon)\n  }, null, 2 /* CLASS */)], 34 /* CLASS, HYDRATE_EVENTS */)]) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\" Caret \"), $props.caret && $props.showOptions ? (0,vue__WEBPACK_IMPORTED_MODULE_1__.renderSlot)(_ctx.$slots, \"caret\", {\n    key: 7\n  }, () => [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"span\", {\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.caret),\n    onClick: _cache[8] || (_cache[8] = (...args) => _ctx.handleCaretClick && _ctx.handleCaretClick(...args)),\n    \"aria-hidden\": \"true\"\n  }, null, 2 /* CLASS */)]) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true)], 16 /* FULL_PROPS */, _hoisted_2), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\" Options \"), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"div\", {\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.dropdown),\n    tabindex: \"-1\"\n  }, [(0,vue__WEBPACK_IMPORTED_MODULE_1__.renderSlot)(_ctx.$slots, \"beforelist\", {\n    options: _ctx.fo\n  }), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"ul\", {\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.options),\n    id: _ctx.ariaControls,\n    role: \"listbox\"\n  }, [$props.groups ? ((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n    key: 0\n  }, (0,vue__WEBPACK_IMPORTED_MODULE_1__.renderList)(_ctx.fg, (group, i, key) => {\n    return (0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(\"li\", {\n      class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.group),\n      key: key,\n      id: _ctx.ariaGroupId(group),\n      \"aria-label\": _ctx.ariaGroupLabel(_ctx.localize(group[$props.groupLabel])),\n      \"aria-selected\": _ctx.isSelected(group),\n      role: \"option\"\n    }, [!group.__CREATE__ ? ((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(\"div\", {\n      key: 0,\n      class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.groupLabel(group)),\n      \"data-pointed\": _ctx.isPointed(group),\n      onMouseenter: $event => _ctx.setPointer(group, i),\n      onClick: $event => _ctx.handleGroupClick(group)\n    }, [(0,vue__WEBPACK_IMPORTED_MODULE_1__.renderSlot)(_ctx.$slots, \"grouplabel\", {\n      group: group,\n      isSelected: _ctx.isSelected,\n      isPointed: _ctx.isPointed\n    }, () => [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"span\", {\n      innerHTML: _ctx.localize(group[$props.groupLabel])\n    }, null, 8 /* PROPS */, _hoisted_11)])], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_10)) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"ul\", {\n      class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.groupOptions),\n      \"aria-label\": _ctx.ariaGroupLabel(_ctx.localize(group[$props.groupLabel])),\n      role: \"group\"\n    }, [((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_1__.renderList)(group.__VISIBLE__, (option, i, key) => {\n      return (0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(\"li\", {\n        class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.option(option, group)),\n        \"data-pointed\": _ctx.isPointed(option),\n        \"data-selected\": _ctx.isSelected(option) || undefined,\n        key: key,\n        onMouseenter: $event => _ctx.setPointer(option),\n        onClick: $event => _ctx.handleOptionClick(option),\n        id: _ctx.ariaOptionId(option),\n        \"aria-selected\": _ctx.isSelected(option),\n        \"aria-label\": _ctx.ariaOptionLabel(_ctx.localize(option[$props.label])),\n        role: \"option\"\n      }, [(0,vue__WEBPACK_IMPORTED_MODULE_1__.renderSlot)(_ctx.$slots, \"option\", {\n        option: option,\n        isSelected: _ctx.isSelected,\n        isPointed: _ctx.isPointed,\n        search: _ctx.search\n      }, () => [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"span\", null, (0,vue__WEBPACK_IMPORTED_MODULE_1__.toDisplayString)(_ctx.localize(option[$props.label])), 1 /* TEXT */)])], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_13);\n    }), 128 /* KEYED_FRAGMENT */))], 10 /* CLASS, PROPS */, _hoisted_12)], 10 /* CLASS, PROPS */, _hoisted_9);\n  }), 128 /* KEYED_FRAGMENT */)) : ((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n    key: 1\n  }, (0,vue__WEBPACK_IMPORTED_MODULE_1__.renderList)(_ctx.fo, (option, i, key) => {\n    return (0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(\"li\", {\n      class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.option(option)),\n      \"data-pointed\": _ctx.isPointed(option),\n      \"data-selected\": _ctx.isSelected(option) || undefined,\n      key: key,\n      onMouseenter: $event => _ctx.setPointer(option),\n      onClick: $event => _ctx.handleOptionClick(option),\n      id: _ctx.ariaOptionId(option),\n      \"aria-selected\": _ctx.isSelected(option),\n      \"aria-label\": _ctx.ariaOptionLabel(_ctx.localize(option[$props.label])),\n      role: \"option\"\n    }, [(0,vue__WEBPACK_IMPORTED_MODULE_1__.renderSlot)(_ctx.$slots, \"option\", {\n      option: option,\n      isSelected: _ctx.isSelected,\n      isPointed: _ctx.isPointed,\n      search: _ctx.search\n    }, () => [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"span\", null, (0,vue__WEBPACK_IMPORTED_MODULE_1__.toDisplayString)(_ctx.localize(option[$props.label])), 1 /* TEXT */)])], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_14);\n  }), 128 /* KEYED_FRAGMENT */))], 10 /* CLASS, PROPS */, _hoisted_8), _ctx.noOptions ? (0,vue__WEBPACK_IMPORTED_MODULE_1__.renderSlot)(_ctx.$slots, \"nooptions\", {\n    key: 0\n  }, () => [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"div\", {\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.noOptions),\n    innerHTML: _ctx.localize($props.noOptionsText)\n  }, null, 10 /* CLASS, PROPS */, _hoisted_15)]) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true), _ctx.noResults ? (0,vue__WEBPACK_IMPORTED_MODULE_1__.renderSlot)(_ctx.$slots, \"noresults\", {\n    key: 1\n  }, () => [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"div\", {\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.noResults),\n    innerHTML: _ctx.localize($props.noResultsText)\n  }, null, 10 /* CLASS, PROPS */, _hoisted_16)]) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true), $props.infinite && _ctx.hasMore ? ((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(\"div\", {\n    key: 2,\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.inifinite),\n    ref: \"infiniteLoader\"\n  }, [(0,vue__WEBPACK_IMPORTED_MODULE_1__.renderSlot)(_ctx.$slots, \"infinite\", {}, () => [(0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"span\", {\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.inifiniteSpinner)\n  }, null, 2 /* CLASS */)])], 2 /* CLASS */)) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.renderSlot)(_ctx.$slots, \"afterlist\", {\n    options: _ctx.fo\n  })], 2 /* CLASS */), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\" Hacky input element to show HTML5 required warning \"), $props.required ? ((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(\"input\", {\n    key: 0,\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.fakeInput),\n    tabindex: \"-1\",\n    value: _ctx.textValue,\n    required: \"\"\n  }, null, 10 /* CLASS, PROPS */, _hoisted_17)) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\" Native input support \"), $props.nativeSupport ? ((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n    key: 1\n  }, [$props.mode == 'single' ? ((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(\"input\", {\n    key: 0,\n    type: \"hidden\",\n    name: $props.name,\n    value: _ctx.plainValue !== undefined ? _ctx.plainValue : ''\n  }, null, 8 /* PROPS */, _hoisted_18)) : ((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n    key: 1\n  }, (0,vue__WEBPACK_IMPORTED_MODULE_1__.renderList)(_ctx.plainValue, (v, i) => {\n    return (0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(\"input\", {\n      type: \"hidden\",\n      name: `${$props.name}[]`,\n      value: v,\n      key: i\n    }, null, 8 /* PROPS */, _hoisted_19);\n  }), 128 /* KEYED_FRAGMENT */))], 64 /* STABLE_FRAGMENT */)) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\" Screen reader assistive text \"), $props.searchable && _ctx.hasSelected ? ((0,vue__WEBPACK_IMPORTED_MODULE_1__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementBlock)(\"div\", {\n    key: 2,\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.assist),\n    id: _ctx.ariaAssist,\n    \"aria-hidden\": \"true\"\n  }, (0,vue__WEBPACK_IMPORTED_MODULE_1__.toDisplayString)(_ctx.ariaLabel), 11 /* TEXT, CLASS, PROPS */, _hoisted_20)) : (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\"v-if\", true), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode)(\" Create height for empty input \"), (0,vue__WEBPACK_IMPORTED_MODULE_1__.createElementVNode)(\"div\", {\n    class: (0,vue__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(_ctx.classList.spacer)\n  }, null, 2 /* CLASS */)], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_1);\n}\nscript.render = render;\nscript.__file = \"src/Multiselect.vue\";\n\n\n//# sourceURL=webpack://azamex-manage-app/./node_modules/@vueform/multiselect/dist/multiselect.mjs?");

/***/ })

}]);